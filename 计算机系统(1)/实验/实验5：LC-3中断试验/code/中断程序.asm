	.ORIG	x2000
	ADD	R6,R6,#-1		;将数据压入栈中
	STR	R0,R6,#0
	ADD	R6,R6,#-1
	STR	R1,R6,#0
	ADD	R6,R6,#-1
	STR	R2,R6,#0
	ADD	R6,R6,#-1
	STR	R3,R6,#0
	ADD	R6,R6,#-1
	STR	R4,R6,#0

	LD	R4,STRING		;IE:字符串首地址
LOOP1	LDI	R1,KBSR			;检查键盘状态
	BRZP	LOOP1
	LDI	R0,KBDR
	LD	R2,BREAK		;判断是否为回车
	ADD	R2,R2,R0
	BRZ	LOOP			;是则结束输入
	STR	R0,R4,#0		;不是则存入字符串
	ADD	R4,R4,#1
	BRNZP	LOOP1
LOOP	AND	R0,R0,#0		;在字符串最后存入回车作为结束标识
	ADD	R0,R0,#10
	STR	R0,R4,#0
NEXT1	AND	R3,R3,#0
	ADD	R3,R3,#10		;R3:计数器,循环十次
LOOP3	LD	R4,STRING
LOOP5	LDR	R0,R4,#0		;读取字符串
	ADD	R4,R4,#1
LOOP4	LDI	R1,DSR			;检查显示器状态
	BRZP	LOOP4
	LD	R2,BREAK		;判断是否为回车
	ADD	R2,R2,R0
	BRZ	NEXT3			;是则进行下一次循环
	STI	R0,DDR			;不是则输出字符
	BRNZP	LOOP5
NEXT3	ADD	R3,R3,#-1
	BRP	LOOP3
NEXT2	LDR	R4,R6,#0		;从栈中取回数据

	ADD	R6,R6,#1
	LDR	R3,R6,#0
	ADD	R6,R6,#1
	LDR	R2,R6,#0
	ADD	R6,R6,#1
	LDR	R1,R6,#0
	ADD	R6,R6,#1
	LDR	R0,R6,#0
	ADD	R6,R6,#1
	RTI				;回到用户程序

KBSR	.FILL	xFE00
KBDR	.FILL	xFE02
DSR	.FILL	xFE04
DDR	.FILL	xFE06
BREAK	.FILL	xFFF6			;-x000A
STRING	.FILL	x4000			;字符串首地址
.END